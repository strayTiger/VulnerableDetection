{"func": "int ENGINE_register_RSA(ENGINE *e) { if (e->rsa_meth) return engine_table_register(&rsa_table,  engine_unregister_all_RSA, e, &dummy_nid,  1, 0); return 1; }", "func_name": "tb_rsa.c_ENGINE_register_RSA.c", "target": 0, "idx": 137505, "project": "OpenSSL"}
{"func": "int tls13_derive_key(SSL *s, const EVP_MD *md, const unsigned char *secret,  unsigned char *key, size_t keylen) { static const unsigned char keylabel[] = \"key\"; return tls13_hkdf_expand(s, md, secret, keylabel, sizeof(keylabel) - 1,  NULL, 0, key, keylen); }", "func_name": "tls13_enc.c_tls13_derive_key.c", "target": 0, "idx": 137649, "project": "OpenSSL"}
{"func": "static int test_signed(int i) { int c = signed_test_values[i]; unsigned int j; int ret = 1; for (j = 0; j < OSSL_NELEM(signed_test_values); ++j) { int d = signed_test_values[j]; if (!test_select_int(c, d) || !test_eq_int(c, d) || !test_eq_int_8(c, d)) ret = 0; } return ret; }", "func_name": "constant_time_test.c_test_signed.c", "target": 0, "idx": 133116, "project": "OpenSSL"}
{"func": "int password_callback(char *buf, int bufsiz, int verify, PW_CB_DATA *cb_tmp) { int res = 0; UI *ui = NULL; PW_CB_DATA *cb_data = (PW_CB_DATA *)cb_tmp; ui = UI_new_method(ui_method); if (ui) { int ok = 0; char *buff = NULL; int ui_flags = 0; const char *prompt_info = NULL; char *prompt; if (cb_data != NULL && cb_data->prompt_info != NULL) prompt_info = cb_data->prompt_info; prompt = UI_construct_prompt(ui, \"pass phrase\", prompt_info); if (!prompt) { BIO_printf(bio_err, \"Out of memory\\n\"); UI_free(ui); return 0; } ui_flags |= UI_INPUT_FLAG_DEFAULT_PWD; UI_ctrl(ui, UI_CTRL_PRINT_ERRORS, 1, 0, 0); (void)UI_add_user_data(ui, cb_data); ok = UI_add_input_string(ui, prompt, ui_flags, buf,  PW_MIN_LENGTH, bufsiz - 1); if (ok >= 0 && verify) { buff = app_malloc(bufsiz, \"password buffer\"); ok = UI_add_verify_string(ui, prompt, ui_flags, buff, PW_MIN_LENGTH, bufsiz - 1, buf); } if (ok >= 0) do { ok = UI_process(ui); } while (ok < 0 && UI_ctrl(ui, UI_CTRL_IS_REDOABLE, 0, 0, 0)); OPENSSL_clear_free(buff, (unsigned int)bufsiz); if (ok >= 0) res = strlen(buf); if (ok == -1) { BIO_printf(bio_err, \"User interface error\\n\"); ERR_print_errors(bio_err); OPENSSL_cleanse(buf, (unsigned int)bufsiz); res = 0; } if (ok == -2) { BIO_printf(bio_err, \"aborted!\\n\"); OPENSSL_cleanse(buf, (unsigned int)bufsiz); res = 0; } UI_free(ui); OPENSSL_free(prompt); } return res; }", "func_name": "apps.c_password_callback.c", "target": 0, "idx": 131707, "project": "OpenSSL"}
{"func": "static int s390x_shake_init(EVP_MD_CTX *evp_ctx) { KECCAK1600_CTX *ctx = evp_ctx->md_data; const size_t bsz = evp_ctx->digest->block_size; switch (bsz) { case S390X_KECCAK1600_BSZ(128): ctx->pad = S390X_SHAKE_128; break; case S390X_KECCAK1600_BSZ(256): ctx->pad = S390X_SHAKE_256; break; default: return 0; } memset(ctx->A, 0, sizeof(ctx->A)); ctx->num = 0; ctx->block_size = bsz; ctx->md_size = evp_ctx->digest->md_size; return 1; }", "func_name": "m_sha3.c_s390x_shake_init.c", "target": 0, "idx": 135410, "project": "OpenSSL"}
{"func": "static int test_early_data_skip_hrr_fail(int idx) { return early_data_skip_helper(2, idx); }", "func_name": "sslapitest.c_test_early_data_skip_hrr_fail.c", "target": 0, "idx": 136741, "project": "OpenSSL"}
